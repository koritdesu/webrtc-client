<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>WebRTC</title>
  <style>
    body {
      position: relative;
      margin: 0;
    }

    video {
      display: block;
      background: #000000;
    }

    video.landscape {
      aspect-ratio: 16/9;
    }

    video.portrait {
      aspect-ratio: 9/16;
    }

    video#local {
      width: 20vw;
      position: absolute;
      right: 20px;
      bottom: 20px;
      z-index: 1;
    }

    video#remote {
      width: 100vw;
    }
  </style>
</head>

<body>
  <video id="local" playsinline autoplay muted></video>
  <video id="remote" playsinline autoplay></video>

  <script>
    (function () {
      const invert = {
        landscape: 'portrait',
        portrait: 'landscape',
      }

      function changeOrientation() {
        const type = screen.orientation.type.substring(0, screen.orientation.type.indexOf('-'));

        if (local.classList.contains(invert[type])) {
          local.classList.replace(invert[type], type);
        } else {
          local.classList.add(type);
        }

        if (remote.classList.contains(invert[type])) {
          remote.classList.replace(invert[type], type);
        } else {
          remote.classList.add(type);
        }
      }

      screen.orientation.addEventListener('change', changeOrientation);
      changeOrientation();
    })();
  </script>

  <script>
    (async function () {
      const url = new URL(location.hash.slice(1));

      const ws = new WebSocket(url);
      const queue = [];

      function send(data) {
        const text = JSON.stringify(data);
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(text);
        } else {
          queue.push(text);
        }
      }

      ws.addEventListener('open', function open() {
        while (queue.length) {
          ws.send(queue.shift());
        }
      });

      ws.addEventListener('close', function close() {
        alert('Connection closed');
      });

      const turn = url.searchParams.get('turn');
      const peerConnection = new RTCPeerConnection({
        iceServers: [
          {
            urls: 'stun:stun.l.google.com:19302',
          },
          {
            urls: [
              `turn:${turn}:3478?transport=udp`,
              `turns:${turn}:5349?transport=tcp`
            ],
            username: url.username,
            credential: url.password,
          }
        ],
        iceTransportPolicy: 'relay',
      });

      peerConnection.addEventListener('icecandidate', function icecandidate(event) {
        if (event.candidate) {
          send({
            type: 'ice',
            data: event.candidate,
          });
        }
      });

      peerConnection.addEventListener('track', function track(event) {
        remote.srcObject = event.streams[0];
      });

      peerConnection.addEventListener('connectionstatechange', function connectionstatechange() {
        if (peerConnection.connectionState === 'failed'
          || peerConnection.connectionState === 'disconnected') {
          endCall();
        }
      });

      const localStream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true,
      });

      local.srcObject = localStream;

      for (const track of localStream.getTracks()) {
        peerConnection.addTrack(track, localStream);
      }

      ws.addEventListener('message', async function message(event) {
        const data = JSON.parse(event.data);

        if (data.type === 'offer' && data.data) {
          await peerConnection.setRemoteDescription(data.data);

          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);

          send({
            type: 'answer',
            data: peerConnection.localDescription,
          });
        } else if (data.type === 'answer' && data.data) {
          await peerConnection.setRemoteDescription(data.data);
        } else if (data.type === 'ice' && data.data) {
          try {
            await peerConnection.addIceCandidate(data.data);
          } catch { }
        } else if (data.type === 'peer-left') {
          endCall();
        } else if (data.type === 'peer-joined') {
          startCall();
          console.log('peer joined');

        }
      });

      async function startCall() {
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        send({
          type: 'offer',
          data: peerConnection.localDescription,
        });
      }

      function endCall() {
        localStream.getTracks().forEach((track) => track.stop());

        peerConnection.getSenders().forEach((sender) => {
          if (sender.track) {
            sender.track.stop();
          }
        });
        peerConnection.close();

        local.srcObject = null;
        remote.srcObject = null;

        ws.close();
      }

      send({
        type: 'join',
        data: url.pathname.slice(1),
      });
    })();
  </script>
</body>

</html>
